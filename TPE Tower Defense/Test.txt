    while(![currentPoint[@"next"] isEqual: @"p0"]) {
        CGPoint destinyLocation = ccp([currentPoint[@"x"] integerValue],[currentPoint[@"y"] integerValue]);
        CGPoint moveDifference = ccpSub(destinyLocation, _jeff.position);
        CGSize winSize = [[CCDirector sharedDirector] viewSize];
        float jeffSpeed = winSize.width / 10.0f;
        float distanceToMove = ccpLength(moveDifference);
        float moveDuration = distanceToMove / jeffSpeed;
        
//        [self.sequenceAction actionWithArray:nil]
        
        [_jeff stopAction:_moveAction];
        _moveAction = [CCActionMoveTo actionWithDuration:moveDuration position:destinyLocation];
        [_jeff runAction:_moveAction ];
//        _waitAction = [CCActionDelay actionWithDuration:moveDuration];
//        [_jeff runAction:_waitAction ];
        
//        while (_jeff.position.x != destinyLocation.x || _jeff.position.y != destinyLocation.y) {
//            // espero
//        }
        
        NSDictionary *nextPoint = [objectGroup objectNamed:currentPoint[@"next"]];
        long x = [nextPoint[@"x"] integerValue];
        long y = [nextPoint[@"y"] integerValue];
        currentPoint = nextPoint;
    }

//    _player.position = ccp(x,y);
//    [self addChild:_player];

    // Obtengo la ubicación en coordenadas de la matriz del tile (int,int)
    
//    CGPoint location = [touch locationInView: [touch view]];
//    location = [[CCDirector sharedDirector] convertToGL: location];
//    CGPoint mappos = [_tileMap convertToNodeSpace:location];
//    mappos.x = (int)(mappos.x / _tileMap.tileSize.height);
//    mappos.y = (int)(mappos.y / _tileMap.tileSize.width);
//    CCLOG(@"X: %f Y: %f\n",mappos.x,mappos.y);
    
//    CGPoint currentTouchPoint = [touch locationInView:[touch view]];
//    CCLOG(@"Posición: X: %f Y: %fn",currentTouchPoint.x,currentTouchPoint.y);
    
    // Recorro todas los lugares posibles donde se puede colocar una torre
//    int ctpx = currentTouchPoint.x - fmod(currentTouchPoint.x,28);
//    int ctpy = currentTouchPoint.y - fmod(currentTouchPoint.y,30);
    
//    NSMutableArray * towerDics = towersGroup.objects;
//    for (NSDictionary * towerDic in towerDics) {
//        int tdx = [towerDic[@"x"] integerValue];
//        int tdy = [towerDic[@"y"] integerValue];
//        if(ctpx > tdx && ctpx < tdx + 28 && ctpy > tdy && ctpy < tdy + 30) {
//            CCLOG(@"CTP: %d, %d  TD: %d, %d\n",ctpx,ctpy,tdx,tdy);
//            break;
//        }
//    }
    
    // TODO Coloco una torre en la posición indicada, pero centrada en la cuadrícula.
    
//    [self ccTouchEnded:touch withEvent:event];

- (void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event
{
    // Jeff se mueve a donde se haya hecho un touch.
    CGPoint touchLocation = [self convertToNodeSpace:touch.locationInWorld];
    CGPoint moveDifference = ccpSub(touchLocation, self.jeff.position);
    CGSize winSize = [[CCDirector sharedDirector] viewSize];
    float jeffSpeed = winSize.width / 10.0f;
    float distanceToMove = ccpLength(moveDifference);
    float moveDuration = distanceToMove / jeffSpeed;
    [self.jeff stopAction:self.moveAction];
    self.moveAction = [CCActionMoveTo actionWithDuration:moveDuration position:touchLocation];
    [self.jeff runAction:self.moveAction];
}

-(CGPoint) tileCoordForPosition: (CGPoint) position
{
    int x = (int)(position.x / _tileMap.tileSize.width);
    int y = ((_tileMap.mapSize.height * _tileMap.tileSize.height) - position.y) / _tileMap.tileSize.height;
    return ccp(x, y);
}
